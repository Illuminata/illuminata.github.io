<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>d҉o҉o҉m҉ - Pre-rendered</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
    .ascii-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #000; cursor: pointer; }
    .ascii-content {
      color: #00ff00; white-space: pre; font-family: inherit;
      font-size: clamp(6px, 1vmin, 12px); line-height: 1;
      width: 100%; height: 100%; display: block; opacity: 1; 
      text-align: left; letter-spacing: 0; margin: 0; padding: 0;
      position: absolute; top: 0; left: 0; background: black;
    }
    .loading { 
      color: #00ff00; 
      position: fixed; top: 50%; left: 50%; 
      transform: translate(-50%, -50%); 
      font-size: 18px; 
      z-index: 1000;
    }
    @media (prefers-reduced-motion: reduce) { .ascii-content { transition: none; } }
  </style>
</head>
<body>
  <div class="ascii-container" id="asciiContainer">
    <div class="ascii-content" id="ascii"></div>
  </div>
  <div class="loading" id="loading">Loading...</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const ascii = document.getElementById('ascii');
      const loading = document.getElementById('loading');
      const container = document.getElementById('asciiContainer');
      
      const CHARS = ' .:-=+*#%@';
      let direction = 1;
      const FPS = 30;
      const frameDuration = 1000 / FPS;
      let lastTime = 0;
      let playing = true;
      let frames = [];
      let frameCache = new Map();
      let currentFrame = 0;
      let videoTime = 0;
      
      function computeDimensions() {
        const fontSize = parseFloat(getComputedStyle(ascii).fontSize) || 8;
        const charWidth = fontSize * 0.6;
        const charHeight = fontSize;
        return { 
          width: Math.ceil(window.innerWidth / charWidth), 
          height: Math.ceil(window.innerHeight / charHeight) 
        };
      }
      
      function resampleFrame(baseFrame, targetW, targetH) {
        const key = `${baseFrame.frame}-${targetW}x${targetH}`;
        if (frameCache.has(key)) return frameCache.get(key);
        
        const baseLines = baseFrame.data.split('\n');
        const baseW = baseFrame.width;
        const baseH = baseFrame.height;
        
        const grid = [];
        for (let y = 0; y < targetH; y++) {
          const row = [];
          for (let x = 0; x < targetW; x++) {
            const srcX = Math.floor((x / targetW) * baseW);
            const srcY = Math.floor((y / targetH) * baseH);
            const char = baseLines[srcY]?.[srcX] || ' ';
            row.push(char);
          }
          grid.push(row.join(''));
        }
        const result = grid.join('\n');
        frameCache.set(key, result);
        return result;
      }
      
      function renderFrame(frameIndex) {
        if (!frames[frameIndex]) return;
        const dim = computeDimensions();
        const scaledData = resampleFrame(frames[frameIndex], dim.width, dim.height);
        ascii.textContent = scaledData;
      }
      
      async function loadFrames(jsonUrl) {
        try {
          loading.textContent = 'Loading...';
          const response = await fetch(jsonUrl);
          const buffer = await response.arrayBuffer();
          const decompressed = pako.inflate(new Uint8Array(buffer));
          const json = new TextDecoder().decode(decompressed);
          frames = JSON.parse(json);
          
          loading.remove();
          renderFrame(0);
          requestAnimationFrame(step);
        } catch (e) {
          loading.textContent = 'Load failed';
          console.error(e);
        }
      }
      
      function step(timestamp) {
        if (!playing || frames.length === 0) {
          requestAnimationFrame(step);
          return;
        }
        
        if (!lastTime) {
          lastTime = timestamp;
          currentFrame = 0;
          renderFrame(0);
          requestAnimationFrame(step);
          return;
        }
        
        const deltaTime = timestamp - lastTime;
        if (deltaTime >= frameDuration) {
          // FRAME-ACCURATE TIMING (matches original video speed)
          currentFrame += direction;
          
          // Ping-pong bounds (exact original logic)
          if (currentFrame >= frames.length - 1) {
            currentFrame = frames.length - 2;
            direction = -1;
          } else if (currentFrame <= 0) {
            currentFrame = 1;
            direction = 1;
          }
          
          renderFrame(currentFrame);
          lastTime = timestamp;
        }
        requestAnimationFrame(step);
      }
      
      container.addEventListener('click', () => {
        playing = !playing;
        container.style.opacity = playing ? '1' : '0.7';
      });
      
      window.addEventListener('resize', () => {
        frameCache.clear();
        if (frames.length > 0) renderFrame(currentFrame);
      });
      
      const JSON_URL = './DSC07313_ascii-frames.json.gz';
      loadFrames(JSON_URL);
    });
  </script>
</body>
</html>
