<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>d҉o҉o҉m҉ - Pre-rendered</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
    .ascii-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: #000; cursor: pointer; }
    .ascii-content {
      color: #00ff00; white-space: pre; font-family: inherit;
      font-size: clamp(6px, 1vmin, 12px); line-height: 1;
      width: 100%; height: 100%; display: block; opacity: 1; 
      text-align: left; letter-spacing: 0; margin: 0; padding: 0;
      position: absolute; top: 0; left: 0; background: black;
    }
    .loading { 
      color: #00ff00; position: fixed; top: 50%; left: 50%; 
      transform: translate(-50%, -50%); font-size: 18px; z-index: 1000;
    }
  </style>
</head>
<body>
  <div class="ascii-container" id="asciiContainer">
    <div class="ascii-content" id="ascii"></div>
  </div>
  <div class="loading" id="loading">Loading...</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const ascii = document.getElementById('ascii');
      const loading = document.getElementById('loading');
      const container = document.getElementById('asciiContainer');
      
      const CHARS = ' .:-=+*#%@';
      let direction = 1;
      const FPS = 30;
      const frameDuration = 1000 / FPS;
      let lastTime = 0;
      let playing = true;
      let frames = [];
      let currentFrame = 0;
      let rafId = null;
      
      // EXACT SAME dimension calc as original
      function computeDimensions() {
        const fontSize = parseFloat(getComputedStyle(ascii).fontSize) || 8;
        const charWidth = fontSize * 0.6;
        const charHeight = fontSize;
        return { width: Math.ceil(window.innerWidth / charWidth), height: Math.ceil(window.innerHeight / charHeight) };
      }
      
      // ULTRA-FAST resampling (prevents stutter)
      const frameCache = new Map();
      function resampleFrame(baseFrame, targetW, targetH) {
        const key = `${baseFrame.frame}-${targetW}x${targetH}`;
        if (frameCache.has(key)) return frameCache.get(key);
        
        const baseLines = baseFrame.data.split('\n');
        const baseW = baseFrame.width;
        const baseH = baseFrame.height;
        let result = '';
        
        for (let y = 0; y < targetH; y++) {
          let row = '';
          for (let x = 0; x < targetW; x++) {
            const srcX = Math.floor(x * baseW / targetW);
            const srcY = Math.floor(y * baseH / targetH);
            row += baseLines[srcY]?.[srcX] || ' ';
          }
          result += row + '\n';
        }
        frameCache.set(key, result);
        return result;
      }
      
      function renderFrame(frameIndex) {
        if (!frames[frameIndex]) return;
        const dim = computeDimensions();
        ascii.textContent = resampleFrame(frames[frameIndex], dim.width, dim.height);
      }
      
      async function loadFrames(jsonUrl) {
        try {
          loading.textContent = 'Loading frames...';
          const response = await fetch(jsonUrl);
          const buffer = await response.arrayBuffer();
          const decompressed = pako.inflate(new Uint8Array(buffer));
          const json = new TextDecoder().decode(decompressed);
          frames = JSON.parse(json);
          
          loading.remove();
          currentFrame = 0;
          renderFrame(0);
          step(performance.now());
        } catch (e) {
          loading.textContent = `Load failed: ${e.message}`;
        }
      }
      
      // FIXED TIMING - Matches original EXACTLY
      function step(timestamp) {
        if (!playing || frames.length === 0) {
          rafId = requestAnimationFrame(step);
          return;
        }
        
        if (!lastTime) {
          lastTime = timestamp;
          rafId = requestAnimationFrame(step);
          return;
        }
        
        const elapsed = timestamp - lastTime;
        if (elapsed >= frameDuration) {
          // Exact frame-stepping like original video renderer
          currentFrame += direction;
          
          // Original ping-pong bounds
          if (currentFrame >= frames.length - 1) {
            currentFrame = frames.length - 2;
            direction = -1;
          } else if (currentFrame <= 0) {
            currentFrame = 1;
            direction = 1;
          }
          
          renderFrame(currentFrame);
          lastTime = timestamp - (elapsed % frameDuration);  // Prevent drift
        }
        
        rafId = requestAnimationFrame(step);
      }
      
      container.addEventListener('click', () => {
        playing = !playing;
        container.style.opacity = playing ? '1' : '0.7';
      });
      
      window.addEventListener('resize', () => {
        frameCache.clear();
        if (frames.length) renderFrame(currentFrame);
      });
      
      const JSON_URL = './DSC07346_ascii-frames.json.gz';
      loadFrames(JSON_URL);
    });
  </script>
</body>
</html>
